# Parallel Data Processing System: Java vs. Go

---

## Overview

A high-performance simulation of parallel data processing that compares the concurrency models of Java and Go. This system demonstrates task distribution, shared resource management, and error handling across multiple worker threads and goroutines.

---

## Project Description

This project implements a Data Processing System where multiple workers retrieve tasks from a shared queue, simulate computational work, and log results to a shared output resource.

It serves as a practical study of the differences between:

* Shared Memory Synchronization (Java)
* Communicating Sequential Processes (Go)

---

## Implementation Details

### Java Implementation

* Model: Shared Memory with Locks
* Concurrency: Uses ExecutorService for thread pooling
* Synchronization: ReentrantLock and Condition variables manage access to the TaskQueue
* Error Handling: Traditional try-catch blocks for checked exceptions (IOException, InterruptedException)

### Go Implementation

* Model: Communicating Sequential Processes (CSP)
* Concurrency: Lightweight Goroutines
* Synchronization: Buffered Channels act as the safe task queue
* Error Handling: Idiomatic Go error returns passed through a results channel to a dedicated logger

---

## Project Structure

```
Parallel-Data-Processing-System/
│
├── DataProcessor.java        # Java concurrency implementation
├── main.go                   # Go concurrency implementation
├── results_java.txt          # Output generated by Java execution
├── results_go.txt            # Output generated by Go execution
└── Documentation.md          # Detailed APA-style comparison report
```

---

## Getting Started

### Prerequisites

* JDK 11 or higher
* Go 1.18 or higher

---

## Running the Project

### Run Java

```
javac DataProcessor.java
java DataProcessor
```

### Run Go

```
go run main.go
```

---

## Key Findings

* Java provides fine‑grained control over thread states but requires careful lock management to avoid deadlocks.
* Go offers a more intuitive concurrency model using channels, reducing synchronization complexity and boilerplate code.

---

## Learning Outcomes

* Understanding concurrency models across languages
* Thread pools vs goroutines comparison
* Lock‑based vs channel‑based synchronization
* Parallel task distribution patterns
* Practical error handling strategies in concurrent systems

---

## Future Improvements

* Add benchmarking module (latency, throughput)
* Add visualization dashboard
* Extend to distributed processing
* Implement priority task scheduling
* Add structured logging

---

## License

This project is intended for educational purposes. You are free to use, modify, and distribute with attribution.

---
